{"docstore/metadata": {"809c7a09-bc3e-4abf-ba61-a80e6f1a0d58": {"doc_hash": "a9d635aef478643ba7171a3bd6d5f857a3fc469e33523c80edefa15bb6f1d47e"}, "541c565b-6c32-4fda-80ab-c045804832c1": {"doc_hash": "b560efad93e412b56594f2c5a9b8ab3617cb2c33ac0893e6eadf5b7cb7bde31d"}, "59231644-079f-4878-ac3a-0b0ad1bc2755": {"doc_hash": "54c8bcec752a3b27d0008b1e962f90a071e3e669e075dd912c12e365506c549d"}, "9df17bf0-1e86-40c7-9e89-f07a280e63df": {"doc_hash": "310b296077369894eb7d5bdc64fd52a10abf48b88ea7b79f2bc9bab67680fb79"}, "3e333308-56cc-450d-b214-b0ac1997a484": {"doc_hash": "6983b15ab25e7515c5d4f6d6985d6448a5340b9a42d9e2886565bc08406b5da9", "ref_doc_id": "809c7a09-bc3e-4abf-ba61-a80e6f1a0d58"}, "077d19cb-9aa0-489b-996f-91f66f9bd76d": {"doc_hash": "c6bc0e009544753d7f43f6701cbe8f20184fbfa8cc70b1f1969a6a435796b1db", "ref_doc_id": "809c7a09-bc3e-4abf-ba61-a80e6f1a0d58"}, "3c786752-fca8-49fb-b73d-be4dc945f202": {"doc_hash": "9075e3bea7ad82092e8494958549e871193cc0c90b4230e87818a889d6a5e84e", "ref_doc_id": "541c565b-6c32-4fda-80ab-c045804832c1"}, "be973696-76ad-46a2-89df-9224dd3f513b": {"doc_hash": "7c6fcb89ecdb8ee12da953cda2f532776d4fc99e265dfddf1429a982ded27bc0", "ref_doc_id": "541c565b-6c32-4fda-80ab-c045804832c1"}, "da836f51-35d9-422e-8424-bdf998b9c20f": {"doc_hash": "de9eb12e6cf6bae5d13265924fa5768eb4859f21ccb9bfb42395a59b3ca72581", "ref_doc_id": "59231644-079f-4878-ac3a-0b0ad1bc2755"}, "407ecf94-1e61-4fa2-82bd-2c43791eb64e": {"doc_hash": "cdca0f41e005d1a80202f846af6b3459da623dc1c754278a12e056778edcd29d", "ref_doc_id": "59231644-079f-4878-ac3a-0b0ad1bc2755"}, "8cd3de04-4d87-4bee-b92b-79beb1000f53": {"doc_hash": "b84fe1a23091a0b4d043a228f944761c3208be995ba03dabf1da44a3fd69fa24", "ref_doc_id": "9df17bf0-1e86-40c7-9e89-f07a280e63df"}, "6e312c99-304b-4f22-95a5-aeb37108a34e": {"doc_hash": "ea96e55b8bb42508cfd6fd1972cbd43d4154f00376efe82c01681e2182fa5fb6", "ref_doc_id": "9df17bf0-1e86-40c7-9e89-f07a280e63df"}, "0f878ca1-88fe-40a2-91c6-51cb89bf9fb9": {"doc_hash": "e1434421e8678f4e78a0272de73051e635b4ea8965d8da8ba20f8bf00de9e626", "ref_doc_id": "9df17bf0-1e86-40c7-9e89-f07a280e63df"}}, "docstore/data": {"3e333308-56cc-450d-b214-b0ac1997a484": {"__data__": {"id_": "3e333308-56cc-450d-b214-b0ac1997a484", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_type": "text/plain", "file_size": 5604, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "809c7a09-bc3e-4abf-ba61-a80e6f1a0d58", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_type": "text/plain", "file_size": 5604, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "a9d635aef478643ba7171a3bd6d5f857a3fc469e33523c80edefa15bb6f1d47e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "077d19cb-9aa0-489b-996f-91f66f9bd76d", "node_type": "1", "metadata": {}, "hash": "a8bc87a2d278c1daf0500164529a4bc440ec78f7ea6525756173bf863d987b08", "class_name": "RelatedNodeInfo"}}, "text": "/* TEMPLATE GENERATED TESTCASE FILE\r\nFilename: CWE78_OS_Command_Injection__char_connect_socket_execl_01.c\r\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\r\nTemplate File: sources-sink-01.tmpl.c\r\n*/\r\n/*\r\n * @description\r\n * CWE: 78 OS Command Injection\r\n * BadSource: connect_socket Read data using a connect socket (client side)\r\n * GoodSource: Fixed string\r\n * Sink: execl\r\n *    BadSink : execute command with execl\r\n * Flow Variant: 01 Baseline\r\n *\r\n * */\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else /* NOT _WIN32 */\r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\r\n#define CLOSE_SOCKET closesocket\r\n#else /* NOT _WIN32 */\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifdef _WIN32\r\n#include <process.h>\r\n#define EXECL _execl\r\n#else /* NOT _WIN32 */\r\n#define EXECL execl\r\n#endif\r\n\r\n#ifndef OMITBAD\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_01_bad()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    {\r\n#ifdef _WIN32\r\n        WSADATA wsaData;\r\n        int wsaDataInit = 0;\r\n#endif\r\n        int recvResult;\r\n        struct sockaddr_in service;\r\n        char *replace;\r\n        SOCKET connectSocket = INVALID_SOCKET;\r\n        size_t dataLen = strlen(data);\r\n        do\r\n        {\r\n#ifdef _WIN32\r\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n            {\r\n                break;\r\n            }\r\n            wsaDataInit = 1;\r\n#endif\r\n            /* POTENTIAL FLAW: Read data using a connect socket */\r\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n            if (connectSocket == INVALID_SOCKET)\r\n            {\r\n                break;\r\n            }\r\n            memset(&service, 0, sizeof(service));\r\n            service.sin_family = AF_INET;\r\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n            service.sin_port = htons(TCP_PORT);\r\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n            {\r\n                break;\r\n            }\r\n            /* Abort on error or the connection was closed, make sure to recv one\r\n             * less char than is in the recv_buf in order to append a terminator */\r\n            /* Abort on error or the connection was closed */\r\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n            {\r\n                break;\r\n            }\r\n            /* Append null terminator */\r\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n            /* Eliminate CRLF */\r\n            replace = strchr(data, '\\r');\r\n            if (replace)\r\n            {\r\n                *replace = '\\0';\r\n            }\r\n            replace = strchr(data, '\\n');\r\n            if (replace)\r\n            {\r\n                *replace = '\\0';\r\n            }\r\n        }\r\n        while (0);\r\n        if (connectSocket != INVALID_SOCKET)\r\n        {\r\n            CLOSE_SOCKET(connectSocket);\r\n        }\r\n#ifdef _WIN32\r\n        if (wsaDataInit)\r\n        {\r\n            WSACleanup();\r\n        }\r\n#endif\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4105, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "077d19cb-9aa0-489b-996f-91f66f9bd76d": {"__data__": {"id_": "077d19cb-9aa0-489b-996f-91f66f9bd76d", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_type": "text/plain", "file_size": 5604, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "809c7a09-bc3e-4abf-ba61-a80e6f1a0d58", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_type": "text/plain", "file_size": 5604, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "a9d635aef478643ba7171a3bd6d5f857a3fc469e33523c80edefa15bb6f1d47e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3e333308-56cc-450d-b214-b0ac1997a484", "node_type": "1", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_type": "text/plain", "file_size": 5604, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "6983b15ab25e7515c5d4f6d6985d6448a5340b9a42d9e2886565bc08406b5da9", "class_name": "RelatedNodeInfo"}}, "text": "}\r\n            /* Append null terminator */\r\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n            /* Eliminate CRLF */\r\n            replace = strchr(data, '\\r');\r\n            if (replace)\r\n            {\r\n                *replace = '\\0';\r\n            }\r\n            replace = strchr(data, '\\n');\r\n            if (replace)\r\n            {\r\n                *replace = '\\0';\r\n            }\r\n        }\r\n        while (0);\r\n        if (connectSocket != INVALID_SOCKET)\r\n        {\r\n            CLOSE_SOCKET(connectSocket);\r\n        }\r\n#ifdef _WIN32\r\n        if (wsaDataInit)\r\n        {\r\n            WSACleanup();\r\n        }\r\n#endif\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif /* OMITBAD */\r\n\r\n#ifndef OMITGOOD\r\n\r\n/* goodG2B uses the GoodSource with the BadSink */\r\nstatic void goodG2B()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    /* FIX: Append a fixed string to data (not user / external input) */\r\n    strcat(data, \"*.*\");\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_01_good()\r\n{\r\n    goodG2B();\r\n}\r\n\r\n#endif /* OMITGOOD */\r\n\r\n/* Below is the main(). It is only used when building this testcase on\r\n * its own for testing or for building a binary to use in testing binary\r\n * analysis tools. It is not used when compiling all the testcases as one\r\n * application, which is how source code analysis tools are tested.\r\n */\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n    /* seed randomness */\r\n    srand( (unsigned)time(NULL) );\r\n#ifndef OMITGOOD\r\n    printLine(\"Calling good()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_01_good();\r\n    printLine(\"Finished good()\");\r\n#endif /* OMITGOOD */\r\n#ifndef OMITBAD\r\n    printLine(\"Calling bad()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_01_bad();\r\n    printLine(\"Finished bad()\");\r\n#endif /* OMITBAD */\r\n    return 0;\r\n}\r\n\r\n#endif", "mimetype": "text/plain", "start_char_idx": 3200, "end_char_idx": 5602, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3c786752-fca8-49fb-b73d-be4dc945f202": {"__data__": {"id_": "3c786752-fca8-49fb-b73d-be4dc945f202", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_type": "text/plain", "file_size": 6701, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "541c565b-6c32-4fda-80ab-c045804832c1", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_type": "text/plain", "file_size": 6701, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "b560efad93e412b56594f2c5a9b8ab3617cb2c33ac0893e6eadf5b7cb7bde31d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "be973696-76ad-46a2-89df-9224dd3f513b", "node_type": "1", "metadata": {}, "hash": "f119198080b156de5fe436bafe0af1d805898094da2bae5bfa241bce60efba2e", "class_name": "RelatedNodeInfo"}}, "text": "/* TEMPLATE GENERATED TESTCASE FILE\r\nFilename: CWE78_OS_Command_Injection__char_connect_socket_execl_02.c\r\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\r\nTemplate File: sources-sink-02.tmpl.c\r\n*/\r\n/*\r\n * @description\r\n * CWE: 78 OS Command Injection\r\n * BadSource: connect_socket Read data using a connect socket (client side)\r\n * GoodSource: Fixed string\r\n * Sink: execl\r\n *    BadSink : execute command with execl\r\n * Flow Variant: 02 Control flow: if(1) and if(0)\r\n *\r\n * */\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else /* NOT _WIN32 */\r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\r\n#define CLOSE_SOCKET closesocket\r\n#else /* NOT _WIN32 */\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifdef _WIN32\r\n#include <process.h>\r\n#define EXECL _execl\r\n#else /* NOT _WIN32 */\r\n#define EXECL execl\r\n#endif\r\n\r\n#ifndef OMITBAD\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_02_bad()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(1)\r\n    {\r\n        {\r\n#ifdef _WIN32\r\n            WSADATA wsaData;\r\n            int wsaDataInit = 0;\r\n#endif\r\n            int recvResult;\r\n            struct sockaddr_in service;\r\n            char *replace;\r\n            SOCKET connectSocket = INVALID_SOCKET;\r\n            size_t dataLen = strlen(data);\r\n            do\r\n            {\r\n#ifdef _WIN32\r\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n                {\r\n                    break;\r\n                }\r\n                wsaDataInit = 1;\r\n#endif\r\n                /* POTENTIAL FLAW: Read data using a connect socket */\r\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n                if (connectSocket == INVALID_SOCKET)\r\n                {\r\n                    break;\r\n                }\r\n                memset(&service, 0, sizeof(service));\r\n                service.sin_family = AF_INET;\r\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n                service.sin_port = htons(TCP_PORT);\r\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n                {\r\n                    break;\r\n                }\r\n                /* Abort on error or the connection was closed, make sure to recv one\r\n                 * less char than is in the recv_buf in order to append a terminator */\r\n                /* Abort on error or the connection was closed */\r\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n                {\r\n                    break;\r\n                }\r\n                /* Append null terminator */\r\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n                /* Eliminate CRLF */\r\n                replace = strchr(data, '\\r');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n                replace = strchr(data, '\\n');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n            }\r\n            while (0);\r\n            if (connectSocket != INVALID_SOCKET)\r\n            {\r\n                CLOSE_SOCKET(connectSocket);\r\n            }\r\n#ifdef _WIN32\r\n            if (wsaDataInit)\r\n            {\r\n                WSACleanup();\r\n            }\r\n#endif\r\n        }\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH,", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4342, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "be973696-76ad-46a2-89df-9224dd3f513b": {"__data__": {"id_": "be973696-76ad-46a2-89df-9224dd3f513b", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_type": "text/plain", "file_size": 6701, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "541c565b-6c32-4fda-80ab-c045804832c1", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_type": "text/plain", "file_size": 6701, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "b560efad93e412b56594f2c5a9b8ab3617cb2c33ac0893e6eadf5b7cb7bde31d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3c786752-fca8-49fb-b73d-be4dc945f202", "node_type": "1", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_type": "text/plain", "file_size": 6701, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "9075e3bea7ad82092e8494958549e871193cc0c90b4230e87818a889d6a5e84e", "class_name": "RelatedNodeInfo"}}, "text": "}\r\n                /* Append null terminator */\r\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n                /* Eliminate CRLF */\r\n                replace = strchr(data, '\\r');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n                replace = strchr(data, '\\n');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n            }\r\n            while (0);\r\n            if (connectSocket != INVALID_SOCKET)\r\n            {\r\n                CLOSE_SOCKET(connectSocket);\r\n            }\r\n#ifdef _WIN32\r\n            if (wsaDataInit)\r\n            {\r\n                WSACleanup();\r\n            }\r\n#endif\r\n        }\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif /* OMITBAD */\r\n\r\n#ifndef OMITGOOD\r\n\r\n/* goodG2B1() - use goodsource and badsink by changing the 1 to 0 */\r\nstatic void goodG2B1()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(0)\r\n    {\r\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\r\n        printLine(\"Benign, fixed string\");\r\n    }\r\n    else\r\n    {\r\n        /* FIX: Append a fixed string to data (not user / external input) */\r\n        strcat(data, \"*.*\");\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\r\nstatic void goodG2B2()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(1)\r\n    {\r\n        /* FIX: Append a fixed string to data (not user / external input) */\r\n        strcat(data, \"*.*\");\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_02_good()\r\n{\r\n    goodG2B1();\r\n    goodG2B2();\r\n}\r\n\r\n#endif /* OMITGOOD */\r\n\r\n/* Below is the main(). It is only used when building this testcase on\r\n * its own for testing or for building a binary to use in testing binary\r\n * analysis tools. It is not used when compiling all the testcases as one\r\n * application, which is how source code analysis tools are tested.\r\n */\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n    /* seed randomness */\r\n    srand( (unsigned)time(NULL) );\r\n#ifndef OMITGOOD\r\n    printLine(\"Calling good()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_02_good();\r\n    printLine(\"Finished good()\");\r\n#endif /* OMITGOOD */\r\n#ifndef OMITBAD\r\n    printLine(\"Calling bad()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_02_bad();\r\n    printLine(\"Finished bad()\");\r\n#endif /* OMITBAD */\r\n    return 0;\r\n}\r\n\r\n#endif", "mimetype": "text/plain", "start_char_idx": 3387, "end_char_idx": 6699, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da836f51-35d9-422e-8424-bdf998b9c20f": {"__data__": {"id_": "da836f51-35d9-422e-8424-bdf998b9c20f", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_type": "text/plain", "file_size": 6722, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "59231644-079f-4878-ac3a-0b0ad1bc2755", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_type": "text/plain", "file_size": 6722, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "54c8bcec752a3b27d0008b1e962f90a071e3e669e075dd912c12e365506c549d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "407ecf94-1e61-4fa2-82bd-2c43791eb64e", "node_type": "1", "metadata": {}, "hash": "3a9b0d3879d9cc2d48c396286e443b0a4d787742e4fb5d01b8065d8de18b3c59", "class_name": "RelatedNodeInfo"}}, "text": "/* TEMPLATE GENERATED TESTCASE FILE\r\nFilename: CWE78_OS_Command_Injection__char_connect_socket_execl_03.c\r\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\r\nTemplate File: sources-sink-03.tmpl.c\r\n*/\r\n/*\r\n * @description\r\n * CWE: 78 OS Command Injection\r\n * BadSource: connect_socket Read data using a connect socket (client side)\r\n * GoodSource: Fixed string\r\n * Sink: execl\r\n *    BadSink : execute command with execl\r\n * Flow Variant: 03 Control flow: if(5==5) and if(5!=5)\r\n *\r\n * */\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else /* NOT _WIN32 */\r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\r\n#define CLOSE_SOCKET closesocket\r\n#else /* NOT _WIN32 */\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifdef _WIN32\r\n#include <process.h>\r\n#define EXECL _execl\r\n#else /* NOT _WIN32 */\r\n#define EXECL execl\r\n#endif\r\n\r\n#ifndef OMITBAD\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_03_bad()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(5==5)\r\n    {\r\n        {\r\n#ifdef _WIN32\r\n            WSADATA wsaData;\r\n            int wsaDataInit = 0;\r\n#endif\r\n            int recvResult;\r\n            struct sockaddr_in service;\r\n            char *replace;\r\n            SOCKET connectSocket = INVALID_SOCKET;\r\n            size_t dataLen = strlen(data);\r\n            do\r\n            {\r\n#ifdef _WIN32\r\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n                {\r\n                    break;\r\n                }\r\n                wsaDataInit = 1;\r\n#endif\r\n                /* POTENTIAL FLAW: Read data using a connect socket */\r\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n                if (connectSocket == INVALID_SOCKET)\r\n                {\r\n                    break;\r\n                }\r\n                memset(&service, 0, sizeof(service));\r\n                service.sin_family = AF_INET;\r\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n                service.sin_port = htons(TCP_PORT);\r\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n                {\r\n                    break;\r\n                }\r\n                /* Abort on error or the connection was closed, make sure to recv one\r\n                 * less char than is in the recv_buf in order to append a terminator */\r\n                /* Abort on error or the connection was closed */\r\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n                {\r\n                    break;\r\n                }\r\n                /* Append null terminator */\r\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n                /* Eliminate CRLF */\r\n                replace = strchr(data, '\\r');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n                replace = strchr(data, '\\n');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n            }\r\n            while (0);\r\n            if (connectSocket != INVALID_SOCKET)\r\n            {\r\n                CLOSE_SOCKET(connectSocket);\r\n            }\r\n#ifdef _WIN32\r\n            if (wsaDataInit)\r\n            {\r\n                WSACleanup();", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4110, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "407ecf94-1e61-4fa2-82bd-2c43791eb64e": {"__data__": {"id_": "407ecf94-1e61-4fa2-82bd-2c43791eb64e", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_type": "text/plain", "file_size": 6722, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "59231644-079f-4878-ac3a-0b0ad1bc2755", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_type": "text/plain", "file_size": 6722, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "54c8bcec752a3b27d0008b1e962f90a071e3e669e075dd912c12e365506c549d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "da836f51-35d9-422e-8424-bdf998b9c20f", "node_type": "1", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_type": "text/plain", "file_size": 6722, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "de9eb12e6cf6bae5d13265924fa5768eb4859f21ccb9bfb42395a59b3ca72581", "class_name": "RelatedNodeInfo"}}, "text": "(char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n                {\r\n                    break;\r\n                }\r\n                /* Append null terminator */\r\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n                /* Eliminate CRLF */\r\n                replace = strchr(data, '\\r');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n                replace = strchr(data, '\\n');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n            }\r\n            while (0);\r\n            if (connectSocket != INVALID_SOCKET)\r\n            {\r\n                CLOSE_SOCKET(connectSocket);\r\n            }\r\n#ifdef _WIN32\r\n            if (wsaDataInit)\r\n            {\r\n                WSACleanup();\r\n            }\r\n#endif\r\n        }\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif /* OMITBAD */\r\n\r\n#ifndef OMITGOOD\r\n\r\n/* goodG2B1() - use goodsource and badsink by changing the 5==5 to 5!=5 */\r\nstatic void goodG2B1()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(5!=5)\r\n    {\r\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\r\n        printLine(\"Benign, fixed string\");\r\n    }\r\n    else\r\n    {\r\n        /* FIX: Append a fixed string to data (not user / external input) */\r\n        strcat(data, \"*.*\");\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\r\nstatic void goodG2B2()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(5==5)\r\n    {\r\n        /* FIX: Append a fixed string to data (not user / external input) */\r\n        strcat(data, \"*.*\");\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_03_good()\r\n{\r\n    goodG2B1();\r\n    goodG2B2();\r\n}\r\n\r\n#endif /* OMITGOOD */\r\n\r\n/* Below is the main(). It is only used when building this testcase on\r\n * its own for testing or for building a binary to use in testing binary\r\n * analysis tools. It is not used when compiling all the testcases as one\r\n * application, which is how source code analysis tools are tested.\r\n */\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n    /* seed randomness */\r\n    srand( (unsigned)time(NULL) );\r\n#ifndef OMITGOOD\r\n    printLine(\"Calling good()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_03_good();\r\n    printLine(\"Finished good()\");\r\n#endif /* OMITGOOD */\r\n#ifndef OMITBAD\r\n    printLine(\"Calling bad()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_03_bad();\r\n    printLine(\"Finished bad()\");\r\n#endif /* OMITBAD */\r\n    return 0;\r\n}\r\n\r\n#endif", "mimetype": "text/plain", "start_char_idx": 3198, "end_char_idx": 6720, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8cd3de04-4d87-4bee-b92b-79beb1000f53": {"__data__": {"id_": "8cd3de04-4d87-4bee-b92b-79beb1000f53", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9df17bf0-1e86-40c7-9e89-f07a280e63df", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "310b296077369894eb7d5bdc64fd52a10abf48b88ea7b79f2bc9bab67680fb79", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6e312c99-304b-4f22-95a5-aeb37108a34e", "node_type": "1", "metadata": {}, "hash": "b9d2a1358a0166f160055f5ab6acfd464f29e6e05ea91ad16dffe4bfb94173db", "class_name": "RelatedNodeInfo"}}, "text": "/* TEMPLATE GENERATED TESTCASE FILE\r\nFilename: CWE78_OS_Command_Injection__char_connect_socket_execl_04.c\r\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\r\nTemplate File: sources-sink-04.tmpl.c\r\n*/\r\n/*\r\n * @description\r\n * CWE: 78 OS Command Injection\r\n * BadSource: connect_socket Read data using a connect socket (client side)\r\n * GoodSource: Fixed string\r\n * Sink: execl\r\n *    BadSink : execute command with execl\r\n * Flow Variant: 04 Control flow: if(STATIC_CONST_TRUE) and if(STATIC_CONST_FALSE)\r\n *\r\n * */\r\n\r\n#include \"std_testcase.h\"\r\n\r\n#include <wchar.h>\r\n\r\n#ifdef _WIN32\r\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\r\n#define COMMAND_INT \"cmd.exe\"\r\n#define COMMAND_ARG1 \"/c\"\r\n#define COMMAND_ARG2 \"dir \"\r\n#define COMMAND_ARG3 data\r\n#else /* NOT _WIN32 */\r\n#include <unistd.h>\r\n#define COMMAND_INT_PATH \"/bin/sh\"\r\n#define COMMAND_INT \"sh\"\r\n#define COMMAND_ARG1 \"-c\"\r\n#define COMMAND_ARG2 \"ls \"\r\n#define COMMAND_ARG3 data\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\r\n#define CLOSE_SOCKET closesocket\r\n#else /* NOT _WIN32 */\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#define INVALID_SOCKET -1\r\n#define SOCKET_ERROR -1\r\n#define CLOSE_SOCKET close\r\n#define SOCKET int\r\n#endif\r\n\r\n#define TCP_PORT 27015\r\n#define IP_ADDRESS \"127.0.0.1\"\r\n\r\n#ifdef _WIN32\r\n#include <process.h>\r\n#define EXECL _execl\r\n#else /* NOT _WIN32 */\r\n#define EXECL execl\r\n#endif\r\n\r\n/* The two variables below are declared \"const\", so a tool should\r\n * be able to identify that reads of these will always return their\r\n * initialized values.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1718, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6e312c99-304b-4f22-95a5-aeb37108a34e": {"__data__": {"id_": "6e312c99-304b-4f22-95a5-aeb37108a34e", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9df17bf0-1e86-40c7-9e89-f07a280e63df", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "310b296077369894eb7d5bdc64fd52a10abf48b88ea7b79f2bc9bab67680fb79", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8cd3de04-4d87-4bee-b92b-79beb1000f53", "node_type": "1", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "b84fe1a23091a0b4d043a228f944761c3208be995ba03dabf1da44a3fd69fa24", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0f878ca1-88fe-40a2-91c6-51cb89bf9fb9", "node_type": "1", "metadata": {}, "hash": "ded08773083c70e19ed12ac927ca83523bef4a9ce1fc783df6ef179b826f1308", "class_name": "RelatedNodeInfo"}}, "text": "*/\r\nstatic const int STATIC_CONST_TRUE = 1; /* true */\r\nstatic const int STATIC_CONST_FALSE = 0; /* false */\r\n\r\n#ifndef OMITBAD\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_04_bad()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(STATIC_CONST_TRUE)\r\n    {\r\n        {\r\n#ifdef _WIN32\r\n            WSADATA wsaData;\r\n            int wsaDataInit = 0;\r\n#endif\r\n            int recvResult;\r\n            struct sockaddr_in service;\r\n            char *replace;\r\n            SOCKET connectSocket = INVALID_SOCKET;\r\n            size_t dataLen = strlen(data);\r\n            do\r\n            {\r\n#ifdef _WIN32\r\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\r\n                {\r\n                    break;\r\n                }\r\n                wsaDataInit = 1;\r\n#endif\r\n                /* POTENTIAL FLAW: Read data using a connect socket */\r\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n                if (connectSocket == INVALID_SOCKET)\r\n                {\r\n                    break;\r\n                }\r\n                memset(&service, 0, sizeof(service));\r\n                service.sin_family = AF_INET;\r\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\r\n                service.sin_port = htons(TCP_PORT);\r\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\r\n                {\r\n                    break;\r\n                }\r\n                /* Abort on error or the connection was closed, make sure to recv one\r\n                 * less char than is in the recv_buf in order to append a terminator */\r\n                /* Abort on error or the connection was closed */\r\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\r\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\r\n                {\r\n                    break;\r\n                }\r\n                /* Append null terminator */\r\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\r\n                /* Eliminate CRLF */\r\n                replace = strchr(data, '\\r');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n                replace = strchr(data, '\\n');\r\n                if (replace)\r\n                {\r\n                    *replace = '\\0';\r\n                }\r\n            }\r\n            while (0);\r\n            if (connectSocket != INVALID_SOCKET)\r\n            {\r\n                CLOSE_SOCKET(connectSocket);\r\n            }\r\n#ifdef _WIN32\r\n            if (wsaDataInit)\r\n            {\r\n                WSACleanup();\r\n            }\r\n#endif\r\n        }\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n#endif /* OMITBAD */\r\n\r\n#ifndef OMITGOOD\r\n\r\n/* goodG2B1() - use goodsource and badsink by changing the STATIC_CONST_TRUE to STATIC_CONST_FALSE */\r\nstatic void goodG2B1()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(STATIC_CONST_FALSE)\r\n    {\r\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\r\n        printLine(\"Benign, fixed string\");\r\n    }\r\n    else\r\n    {\r\n        /* FIX: Append a fixed string to data (not user / external input) */\r\n        strcat(data, \"*.*\");\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\r\nstatic void goodG2B2()\r\n{\r\n    char * data;\r\n    char dataBuffer[100] = COMMAND_ARG2;\r\n    data = dataBuffer;\r\n    if(STATIC_CONST_TRUE)\r\n    {\r\n        /* FIX: Append a fixed string to data (not user / external input) */\r\n        strcat(data, \"*.*\");\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_04_good()\r\n{\r\n    goodG2B1();\r\n    goodG2B2();\r\n}\r\n\r\n#endif /* OMITGOOD */\r\n\r\n/* Below is the main().", "mimetype": "text/plain", "start_char_idx": 1721, "end_char_idx": 6303, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0f878ca1-88fe-40a2-91c6-51cb89bf9fb9": {"__data__": {"id_": "0f878ca1-88fe-40a2-91c6-51cb89bf9fb9", "embedding": null, "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9df17bf0-1e86-40c7-9e89-f07a280e63df", "node_type": "4", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "310b296077369894eb7d5bdc64fd52a10abf48b88ea7b79f2bc9bab67680fb79", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6e312c99-304b-4f22-95a5-aeb37108a34e", "node_type": "1", "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}, "hash": "ea96e55b8bb42508cfd6fd1972cbd43d4154f00376efe82c01681e2182fa5fb6", "class_name": "RelatedNodeInfo"}}, "text": "*\");\r\n    }\r\n    /* execl - specify the path where the command is located */\r\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\r\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\r\n}\r\n\r\nvoid CWE78_OS_Command_Injection__char_connect_socket_execl_04_good()\r\n{\r\n    goodG2B1();\r\n    goodG2B2();\r\n}\r\n\r\n#endif /* OMITGOOD */\r\n\r\n/* Below is the main(). It is only used when building this testcase on\r\n * its own for testing or for building a binary to use in testing binary\r\n * analysis tools. It is not used when compiling all the testcases as one\r\n * application, which is how source code analysis tools are tested.\r\n */\r\n\r\n#ifdef INCLUDEMAIN\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n    /* seed randomness */\r\n    srand( (unsigned)time(NULL) );\r\n#ifndef OMITGOOD\r\n    printLine(\"Calling good()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_04_good();\r\n    printLine(\"Finished good()\");\r\n#endif /* OMITGOOD */\r\n#ifndef OMITBAD\r\n    printLine(\"Calling bad()...\");\r\n    CWE78_OS_Command_Injection__char_connect_socket_execl_04_bad();\r\n    printLine(\"Finished bad()\");\r\n#endif /* OMITBAD */\r\n    return 0;\r\n}\r\n\r\n#endif", "mimetype": "text/plain", "start_char_idx": 5872, "end_char_idx": 7087, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"809c7a09-bc3e-4abf-ba61-a80e6f1a0d58": {"node_ids": ["3e333308-56cc-450d-b214-b0ac1997a484", "077d19cb-9aa0-489b-996f-91f66f9bd76d"], "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_01.c", "file_type": "text/plain", "file_size": 5604, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}}, "541c565b-6c32-4fda-80ab-c045804832c1": {"node_ids": ["3c786752-fca8-49fb-b73d-be4dc945f202", "be973696-76ad-46a2-89df-9224dd3f513b"], "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_02.c", "file_type": "text/plain", "file_size": 6701, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}}, "59231644-079f-4878-ac3a-0b0ad1bc2755": {"node_ids": ["da836f51-35d9-422e-8424-bdf998b9c20f", "407ecf94-1e61-4fa2-82bd-2c43791eb64e"], "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_03.c", "file_type": "text/plain", "file_size": 6722, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}}, "9df17bf0-1e86-40c7-9e89-f07a280e63df": {"node_ids": ["8cd3de04-4d87-4bee-b92b-79beb1000f53", "6e312c99-304b-4f22-95a5-aeb37108a34e", "0f878ca1-88fe-40a2-91c6-51cb89bf9fb9"], "metadata": {"file_path": "D:\\Desktop\\xas\\FALCON\\gjj_decision_agent\\storage\\small\\CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_name": "CWE78_OS_Command_Injection__char_connect_socket_execl_04.c", "file_type": "text/plain", "file_size": 7089, "creation_date": "2025-04-21", "last_modified_date": "2025-04-13"}}}}